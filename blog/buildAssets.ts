// =============================================================
// Asset Manager
// =============================================================

import axios from 'axios';
import {
    access,
    constants,
    mkdir,
    readdir,
    readFile,
    writeFile,
} from 'node:fs/promises';
import sharp from 'sharp';

import { BlogPostMetadata } from '@/types/BlogPostMetadata';

const CONTENT_FOLDER = '../content';
const ASSETS_FOLDER = 'assets';

const ImageFormats = ['webp', 'png', 'jpg', 'jpeg'];

type ImageSettings = {
    prefix?: string;
    suffix?: string;
    width: number;
    height: number;
    // quality?: number; // default 75
    format?: string; // default webp
};

type ENStateResponse = {
    name: string;
    address: string;
    avatar: string;
    display: string;
};

const makeDirecectoryIfNotExists = async (path: string) => {
    try {
        await access(path, constants.F_OK | constants.W_OK | constants.R_OK);
    } catch {
        await mkdir(path);
    }
};

const writeOutput = async (items: string[]) => {
    const disclaimer = `/* eslint-disable prettier/prettier */
/*
 This file is auto generated by the asset manager
 Do not edit this file directly
 */

type StaticImageData = {
    src: string;
    height: number;
    width: number;
    blurDataURL?: string;
    blurWidth?: number;
    blurHeight?: number;
};
`;

    await writeFile(
        `${ASSETS_FOLDER}/assets.ts`,
        disclaimer + items.join('\n\n') + '\n',
        'utf8'
    );
};

// =============================================================
// Handle cover images
// =============================================================

const COVER_IMG_SETTINGS: ImageSettings[] = [
    {
        width: 1920,
        height: 1080,
    },
    {
        suffix: 'thumb',
        width: 426 * 1.5,
        height: 240 * 1.5,
    },
];

type Cover = {
    post: string;
    format: string;
    data: Buffer;
};

const getCoverImages = async () => {
    const posts = await readdir(CONTENT_FOLDER);

    console.log('Posts', posts);

    const covers: Cover[] = [];

    for (const post of posts) {
        // Check if post has cover a cover .ImageFormats
        let foundImageFile = false;

        for (const format of ImageFormats) {
            const cover = `${CONTENT_FOLDER}/${post}/cover.${format}`;

            console.log('Checking', cover);

            try {
                await access(cover, constants.F_OK | constants.R_OK);
                const data = await readFile(cover);

                covers.push({
                    post,
                    format,
                    data,
                });

                foundImageFile = true;
                break;
            } catch {
                // Ignore error
            }
        }

        if (foundImageFile) continue;

        // Read meta.json and check for cover
        const meta = await import(`../content/${post}/meta.json`).catch(
            () => { }
        );

        if (meta?.cover) {
            // Check if cover is a valid URL
            let url: URL;

            try {
                url = new URL(meta.cover);
            } catch {
                continue;
            }

            if (url.protocol === 'http:' || url.protocol === 'https:') {
                const data = await axios({
                    method: 'get',
                    url: meta.cover,
                    responseType: 'arraybuffer',
                })
                    .then((response) => Buffer.from(response.data))
                    .catch(() => {
                        console.log('Failed to fetch cover image', meta.cover);
                    });

                if (!data) continue;

                const format = url.pathname.split('.').pop() || 'webp';

                covers.push({
                    post,
                    format,
                    data,
                });
            }
        }
    }

    return covers;
};

const handleCoverImages = async () => {
    const covers = await getCoverImages();

    let result = 'export const covers = {\n';

    for (const cover of covers) {
        result += `    '${cover.post}': {\n`;

        for (const settings of COVER_IMG_SETTINGS) {
            const { prefix, suffix, width, height, format } = settings;

            // eslint-disable-next-line sonarjs/no-nested-template-literals
            const key = `${prefix || ''}cover${suffix ? `-${suffix}` : ''}`;
            const output = `${ASSETS_FOLDER}/${cover.post}/${key}.${format || 'webp'
                }`;

            console.log(`Converting image to ${output}`);

            await makeDirecectoryIfNotExists(`${ASSETS_FOLDER}/${cover.post}`);

            await sharp(cover.data).resize(width, height).toFile(output);

            result += `        '${key}': import('./${cover.post}/${key}.${format || 'webp'
                }') as Promise<{default: StaticImageData}>,\n`;
        }

        result += '    },\n';
    }

    result += '};';

    result +=
        '\n\nexport type Cover = keyof typeof covers[keyof typeof covers];';

    return result;
};

// =============================================================
// Handle avatars
// =============================================================

const AVATAR_IMG_SETTINGS: ImageSettings[] = [
    {
        width: 512,
        height: 512,
    },
];

const getAvatarImages = async () => {
    const posts = await readdir(CONTENT_FOLDER);

    console.log('Posts', posts);

    const avatars: Record<string, Buffer> = {};

    for (const post of posts) {
        // Read meta.json and check for cover
        const meta: BlogPostMetadata = await import(
            `../content/${post}/meta.json`
        ).catch(() => { });

        if (!meta) continue;

        for (const author of meta.authors) {
            if (avatars[author]) continue;

            let avatar: Buffer | undefined | void;

            const enstateData = await axios({
                method: 'get',
                url: `https://enstate.rs/n/${author}`,
                // responseType: 'arraybuffer',
            })
                .then((response) => response.data as ENStateResponse)
                .catch(() => {
                    // console.log(
                    //     'Failed to fetch avatar image via enstate',
                    //     author
                    // );
                });

            if (enstateData && enstateData.avatar) {
                avatar = await axios({
                    method: 'get',
                    url: enstateData.avatar,
                    responseType: 'arraybuffer',
                })
                    .then((response) => Buffer.from(response.data))
                    .catch(() => {
                        // console.log(
                        //     'Failed to fetch avatar image via enstate',
                        //     author
                        // );
                    });
            }

            if (!avatar) {
                avatar = await axios({
                    method: 'get',
                    url: `https://metadata.ens.domains/mainnet/avatar/${author}`,
                    responseType: 'arraybuffer',
                })
                    .then((response) => Buffer.from(response.data))
                    .catch(() => {
                        // console.log(
                        //     'Failed to fetch avatar image via metadata',
                        //     author
                        // );
                    });
            }

            if (!avatar) {
                console.log('No avatar found for author', author);
                continue;
            }

            avatars[author] = avatar;

            console.log('Found avatar for author', author);
        }
    }

    return avatars;
};

const handleAvatarImages = async () => {
    const avatars = await getAvatarImages();

    let result = 'export const avatars = {\n';

    for (const [author, avatar] of Object.entries(avatars)) {
        result += `    '${author}': {\n`;

        for (const settings of AVATAR_IMG_SETTINGS) {
            const { prefix, suffix, width, height, format } = settings;

            // eslint-disable-next-line sonarjs/no-nested-template-literals
            const key = `${prefix || ''}avatar${suffix ? `-${suffix}` : ''}`;
            const output = `${ASSETS_FOLDER}/${author}/${key}.${format || 'webp'
                }`;

            console.log(`Converting image to ${output}`);

            await makeDirecectoryIfNotExists(`${ASSETS_FOLDER}/${author}`);

            try {
                await sharp(avatar, {
                    pages: -1,
                    animated: true,
                })
                    .resize(width, height)
                    .toFile(output);
            } catch (error) {
                console.log('Failed to convert image', error);
                continue;
            }


            result += `        '${key}': import('./${author}/${key}.${format || 'webp'
                }') as Promise<{default: StaticImageData}>,\n`;
        }

        result += '    },\n';
    }

    result += '};';

    result +=
        '\n\nexport type Avatar = keyof typeof avatars[keyof typeof avatars];';

    return result;
};

// =============================================================
// Main
// =============================================================

const main = async () => {
    // Make sure assets folder exists using fs/promises
    await makeDirecectoryIfNotExists(ASSETS_FOLDER);

    const coverOutput = await handleCoverImages();

    const avatarOutput = await handleAvatarImages();

    await writeOutput([coverOutput, avatarOutput]);
};

main();
